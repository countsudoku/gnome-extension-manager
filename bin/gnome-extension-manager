#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
"""
GNOME-Extension-Manager

This little program is used to manage the GNOME Extensions in user space. The
commands should be similar than the ones are used for apt-get in Debian like
Linux distributions.
"""

import subprocess
import re
import urllib2
import json
import os
import sys
import tempfile
import zipfile

# Some default values
DEFAULT_BASE_URL = 'https://extensions.gnome.org'

DEFAULT_CONFIG_DIR = os.getenv('XDG_CONFIG_HOME',
        os.path.join(os.environ['HOME'], '.config'))
DEFAULT_CACHE_DIR = os.getenv('XDG_CACHE_HOME',
        os.path.join(os.environ['HOME'], '.cache'))
DEFAULT_DATA_DIR = os.getenv('XDG_DATA_HOME',
        os.path.join(os.environ['HOME'], '.local/share'))

DEFAULT_INSTALL_DIR = os.path.join(DEFAULT_DATA_DIR,
        'gnome-shell',
        'extensions')
DEFAULT_GLOBAL_INSTALL_DIR = '/usr/share/gnome-shell/extensions'

DEFAULT_CONFIG_FILE = os.path.join(DEFAULT_CONFIG_DIR,
        'gnome-extension-manager',
        'config.ini')

def get_gnome_shell_version():
    """
    This function is to get the installed gnome-shell version
    """
    gnome_shell_version = re.sub(r'^\s*GNOME\s*Shell\s*((\d+\.)+\d+).*$', r'\1',
            subprocess.check_output(['gnome-shell', '--version'])
            )
    return gnome_shell_version.rstrip()

def gnome_versions_stack(version):
    """
    Returns a stack (list) of versions; with the most specific at top and the
    unspecific at bottom.

    So if you version is 3.15.1 the list is [ 3, 3.15, 3.15.1 ]
    """

    split_version = version.split('.')
    versions = []
    while split_version:
        versions.append('.'.join(split_version))
        del split_version[-1]

    versions.reverse()

    return versions

def gnome_query(baseurl, query, part=''):
    """
    This function downloads the catalog from the given url with the given
    query
    """
    try:
        response = urllib2.urlopen('{0}/{1}'.format(baseurl, query))
    except urllib2.HTTPError, e:
        print 'The server couldn\'t fulfill the request.'
        print 'Error code: ', e.code
        sys.exit(1)
    except urllib2.URLError, e:
        print 'We failed to reach a server.'
        print 'Reason: ', e.reason
        sys.exit(1)

    info = response.read()
    if part == '':
        return json.loads(info)
    else:
        return json.loads(info)[part]
def download_progress(bytes_so_far, chunk_size, total_size):
    """
    A simple function, which prints the percent of progress.
    """

    percent = float(bytes_so_far)/total_size
    percent = round(percent*100, 2)
    print "downloaded {0} % of {1} bytes".format(percent, total_size)

def download_extension(url, dest_file, report_hook=None):
    """
    Download the given url to a file and reports the progress
    """
    try:
        response = urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        print 'The server couldn\'t fulfill the request.'
        print 'Error code: ', e.code
        sys.exit(1)
    except urllib2.URLError, e:
        print 'We failed to reach a server.'
        print 'Reason: ', e.reason
        sys.exit(1)
    total_size = response.info().getheader('Content-Length')
    total_size = int(total_size)
    bytes_so_far = 0
    chunk_size = 1024 * 8

    while True:
        chunk = response.read(chunk_size)
        bytes_so_far += len(chunk)

        if not chunk:
            break

        dest_file.write(chunk)

        if report_hook:
            report_hook(bytes_so_far, chunk_size, total_size)

def update_catalog(catalog_file, url):
    """
    This function downloads the catalog and compares it with the saved one.
    Then it should download the missing information and save the catalog
    again.

    dependencies: gnome_query, get_gnome_shell_version
    """

    if not os.path.exists(catalog_file):
        directory = os.path.dirname(catalog_file)
        if not os.path.exists(directory):
            os.makedirs(directory)

    print("getting extensions information...")
    catalog = gnome_query(url,
            'extension-query/?n_per_page=-1',
            'extensions'
            )

    with open(catalog_file, 'w') as f:
        json.dump({"extensions": catalog}, f)

def find_in_catalog(catalog, extension, shell_version):
    """
    Find the Extension in the catalog and return some usefull information
    """
    if re.match(r'^\d+$', extension):
        ext_type = "pk"
        extension = int(extension)
    elif re.match(r'^.*@.*', extension):
        ext_type = "uuid"
    else:
        raise Exception("{0}is no valid Extension UUID nor a valid Package number!".format(extension))

    found = False
    for i in range(len(catalog)):
        if catalog[i][ext_type] == extension:
            found = True
            catalog_num = i
            break

    if not found:
        raise Exception("Can't find extension {0} in the catalog".format(extension))

    shell_versions_stack = gnome_versions_stack(shell_version)
    test_version = shell_versions_stack.pop()

    while test_version not in catalog[catalog_num]['shell_version_map']:
        if not shell_versions_stack:
            raise Exception("Can't find extension {0} for your version of GNOME Shell".format(extension))
        else:
            test_version = shell_versions_stack.pop()

    # TODO: This should be an object
    return {"install_pk" : catalog[catalog_num]["shell_version_map"][test_version]["pk"],
            "version": catalog[catalog_num]["shell_version_map"][test_version]["version"],
            "name": catalog[catalog_num]["name"],
            "creator": catalog[catalog_num]["creator"],
            "description": catalog[catalog_num]["description"],
            "uuid": catalog[catalog_num]["uuid"],
            }

def install_extension(url, install_dir, uuid, install_pk):
    """
    This function should install a single extension to the user directory
    """

    with tempfile.SpooledTemporaryFile() as f:
        print("download extension {0}".format(uuid))
        download_extension(
                "{0}/download-extension/{1}.shell-extension.zip?version_tag={2}".format(url, uuid, install_pk),
                f,
                report_hook=download_progress
                )
        print("install extension {0}".format(uuid))
        install_directory = os.path.join(install_dir, uuid)
        if not os.path.exists(install_directory):
            os.makedirs(install_directory)
        with zipfile.ZipFile(f, 'r') as z:
            z.extractall(install_directory)

def install_all_extensions(extensions, catalog_file, url, shell_version, install_dir):
    """
    This function get a list of extensions make some checks and then installs
    it in the correct version. The version which is installed is obtained
    from the catalog.
    """

    try:
        with open(catalog_file, 'r') as f:
            catalog = json.load(f)['extensions']
    except IOError:
        print("Can't find catalog file please run '{0} update' first".format(__file__))
        sys.exit(1)

    for extension in extensions:
        ext_info = find_in_catalog(catalog, extension, shell_version)
        install_extension(url, install_dir, ext_info["uuid"], ext_info["install_pk"])


def init_argparser():
    """
    This function does the whole parsing oft command line arguments
    """
    import argparse

    parser = argparse.ArgumentParser()

    parser.add_argument('-c', '--config',
            help='specify an alternative configuratin file. (default: {0})'.format(DEFAULT_CONFIG_FILE),
            default=DEFAULT_CONFIG_FILE,
            dest='config_file'
            )

    # Setup subcommands
    sub_commands = parser.add_subparsers(dest='command')

    # Adding all the subcommands
    install = sub_commands.add_parser('install',
            help='Download and install the extension'
            )
    remove = sub_commands.add_parser('remove',
            help='Deinstall an extension'
            )
    purge = sub_commands.add_parser('purge',
            help='Deinstall an extension and remove the configuration'
            )
    update = sub_commands.add_parser('update',
            help='Update the extensions catalog'
            )
    upgrade = sub_commands.add_parser('upgrade',
            help='Update the installed extensions'
            )
    activate = sub_commands.add_parser('activate',
            help='Activate an extensions'
            )
    deactivate = sub_commands.add_parser('deactivate',
            help='Deactivate an extensions'
            )

    install.add_argument('extensions', nargs='+')
    remove.add_argument('extensions', nargs='+')
    purge.add_argument('extensions', nargs='+')
    upgrade.add_argument('extensions', nargs='*')
    activate.add_argument('extensions', nargs='+')
    deactivate.add_argument('extensions', nargs='+')

    return parser

if __name__ == '__main__':
    args, extra_args = init_argparser().parse_known_args()

    catalog_file = os.path.join(DEFAULT_CACHE_DIR,
            'gnome-extension-manager',
            'catalog.json')

    shell_version = get_gnome_shell_version()

    if args.command == 'update':
        #update_catalog(catalog_file, DEFAULT_BASE_URL)
        print args.config_file
    #elif args.command == 'install':
    #    install_all_extensions(args.extensions, catalog_file, DEFAULT_BASE_URL, shell_version, DEFAULT_INSTALL_DIR)
