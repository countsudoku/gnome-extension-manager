#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
"""
GNOME-Extension-Manager

This little program is used to manage the GNOME Extensions in user space. The
commands should be similar than the ones are used for apt-get in Debian like
Linux distributions.
"""

import subprocess
import re
import urllib2
import json
import os
import sys
import tempfile

#TODO: The url should be configurable
BASE_URL = 'https://extensions.gnome.org'

CONFIG_DIR = os.getenv('XDG_CONFIG_HOME',
        os.path.join(os.environ['HOME'], '.config'))
CACHE_DIR = os.getenv('XDG_CACHE_HOME',
        os.path.join(os.environ['HOME'], '.cache'))
DATA_DIR = os.getenv('XDG_DATA_HOME',
        os.path.join(os.environ['HOME'], '.share'))

INSTALL_DIR = os.path.join(DATA_DIR, 'gnome-shell', 'extensions')


def get_gnome_shell_version():
    """
    This function is to get the installed gnome-shell version
    """
    gnome_shell_version = re.sub(r'^\s*GNOME\s*Shell\s*((\d+\.)+\d+).*$', r'\1',
            subprocess.check_output(['gnome-shell', '--version'])
            )
    return gnome_shell_version.rstrip()

def gnome_versions_stack(version):
    split_version = version.split('.')
    versions = []
    while split_version:
        versions.append('.'.join(split_version))
        del split_version[-1]

    versions.reverse()

    return versions

def gnome_query(baseurl, query, part=''):
    """
    This function downloads the catalog from the given url with the given
    query
    """
    try:
        response = urllib2.urlopen('{0}/{1}'.format(baseurl, query))
    except urllib2.HTTPError, e:
        print 'The server couldn\'t fulfill the request.'
        print 'Error code: ', e.code
        sys.exit(1)
    except urllib2.URLError, e:
        print 'We failed to reach a server.'
        print 'Reason: ', e.reason
        sys.exit(1)

    info = response.read()
    if part == '':
        return json.loads(info)
    else:
        return json.loads(info)[part]

def download_extension(url, dest_file):
    try:
        response = urllib2.urlopen(url)
    except urllib2.HTTPError, e:
        print 'The server couldn\'t fulfill the request.'
        print 'Error code: ', e.code
        sys.exit(1)
    except urllib2.URLError, e:
        print 'We failed to reach a server.'
        print 'Reason: ', e.reason
        sys.exit(1)
    total_size = response.info().getheader('Content-Length')
    total_size = int(total_size)

def update_catalog(catalog_file, url):
    """
    This function downloads the catalog and compares it with the saved one.
    Then it should download the missing information and save the catalog
    again.

    dependencies: gnome_query, get_gnome_shell_version
    """

    if not os.path.exists(catalog_file):
        directory = os.path.dirname(catalog_file)
        if not os.path.exists(directory):
            os.makedirs(directory)

    print("getting extensions information...")
    catalog = gnome_query(url,
            'extension-query/?n_per_page=-1',
            'extensions'
            )

    with open(catalog_file, 'w') as f:
        json.dump({"extensions": catalog}, f)

def find_in_catalog(catalog, extension, shell_version):
    """
    Find the Extension in the catalog and return some usefull information
    """
    if re.match(r'^\d+$', extension):
        ext_type = "pk"
        extension = int(extension)
    elif re.match(r'^.*@.*', extension):
        ext_type = "uuid"
    else:
        raise Exception("{0}is no valid Extension UUID nor a valid Package number!".format(extension))

    found = False
    for i in range(len(catalog)):
        if catalog[i][ext_type] == extension:
            found = True
            catalog_num = i
            break

    if not found:
        raise Exception("Can't find extension {0} in the catalog".format(extension))

    shell_versions_stack = gnome_versions_stack(shell_version)
    test_version = shell_versions_stack.pop()

    while test_version not in catalog[catalog_num]['shell_version_map']:
        if not shell_versions_stack:
            raise Exception("Can't find extension {0} for your version of GNOME Shell".format(extension))
        else:
            test_version = shell_versions_stack.pop()

    # TODO: This should be an object
    return {"install_pk" : catalog[catalog_num]["shell_version_map"][test_version]["pk"],
            "version": catalog[catalog_num]["shell_version_map"][test_version]["version"],
            "name": catalog[catalog_num]["name"],
            "creator": catalog[catalog_num]["creator"],
            "description": catalog[catalog_num]["description"],
            "uuid": catalog[catalog_num]["uuid"],
            }

def install_extension(extensions, catalog_file, url, shell_version):
    try:
        with open(catalog_file, 'r') as f:
            catalog = json.load(f)['extensions']
    except IOError as e:
        print("Can't find catalog file please run '{0} update' first".format(__file__))
        sys.exit(1)

    for extension in extensions:
        ext_info = find_in_catalog(catalog, extension, shell_version)
        print ext_info["uuid"], ext_info["install_pk"]

        with tempfile.SpooledTemporaryFile() as f:
            download_extension(
                    "{0}/download-extension/{1}.shell-extension.zip?version_tag={2}".format(url, ext_info["uuid"], ext_info["install_pk"]),
                    f
                    )


def init_argparser():
    """
    This function does the whole parsing oft command line arguments
    """
    import argparse

    parser = argparse.ArgumentParser()

    # Setup subcommands
    sub_commands = parser.add_subparsers(dest='command')

    # Adding all the subcommands
    install = sub_commands.add_parser('install',
            help='Download and install the extension'
            )
    remove = sub_commands.add_parser('remove',
            help='Deinstall an extension'
            )
    purge = sub_commands.add_parser('purge',
            help='Deinstall an extension and remove the configuration'
            )
    update = sub_commands.add_parser('update',
            help='Update the extensions catalog'
            )
    upgrade = sub_commands.add_parser('upgrade',
            help='Update the installed extensions'
            )
    activate = sub_commands.add_parser('activate',
            help='Activate an extensions'
            )
    deactivate = sub_commands.add_parser('deactivate',
            help='Deactivate an extensions'
            )

    install.add_argument('extensions', nargs='+')
    remove.add_argument('extensions', nargs='+')
    purge.add_argument('extensions', nargs='+')
    upgrade.add_argument('extensions', nargs='*')
    activate.add_argument('extensions', nargs='+')
    deactivate.add_argument('extensions', nargs='+')

    return parser

if __name__ == '__main__':
    args, extra_args = init_argparser().parse_known_args()

    catalog_file = os.path.join(CACHE_DIR,
            'gnome-extension-manager',
            'catalog.json')

    shell_version = get_gnome_shell_version()

    if args.command == 'update':
        update_catalog(catalog_file, BASE_URL)
    elif args.command == 'install':
        install_extension(args.extensions, catalog_file, BASE_URL, shell_version)

