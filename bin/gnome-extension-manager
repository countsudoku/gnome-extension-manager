#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
"""
GNOME-Extension-Manager

This little program is used to manage the GNOME Extensions in user space. The
commands should be similar than the ones are used for apt-get in Debian like
Linux distributions.
"""

import subprocess
import re
import urllib2
import os
import sys
import tempfile
import zipfile
from json import JSONDecoder,JSONEncoder
from datetime import datetime

# Some default values
VERSION = "0.0.1"

DEFAULT_BASE_URL = 'https://extensions.gnome.org'
DEFAULT_QUERY = '/extension-query/?n_per_page=-1'
DEFAULT_ITEM = 'extensions'
DEFAULT_TIMEOUT = 60

DEFAULT_GLOBAL_INSTALL_DIR = '/usr/share/gnome-shell/extensions'

if os.getuid() == 0:
    DEFAULT_INSTALL_DIR = DEFAULT_GLOBAL_INSTALL_DIR
    DEFAULT_CONFIG_DIR = '/etc'
    DEFAULT_CACHE_DIR = '/var/cache'
else:
    DEFAULT_HOME = os.environ['HOME']
    DEFAULT_CONFIG_DIR = os.getenv('XDG_CONFIG_HOME',
            os.path.join(DEFAULT_HOME, '.config'))
    DEFAULT_CACHE_DIR = os.getenv('XDG_CACHE_HOME',
            os.path.join(DEFAULT_HOME, '.cache'))
    DEFAULT_DATA_DIR = os.getenv('XDG_DATA_HOME',
            os.path.join(DEFAULT_HOME, '.local/share'))
    DEFAULT_INSTALL_DIR = os.path.join(DEFAULT_DATA_DIR,
            'gnome-shell',
            'extensions')


DEFAULT_CONFIG_FILE = os.path.join(DEFAULT_CONFIG_DIR,
        'gnome-extension-manager',
        'config.ini')

class Extension(object):
    """
    This class does the extension parsing and installing
    """
    def __init__(self, *path):
        pass

    def __str__(self):
        pass

    def __cmp__(self):
        pass

    def get_from_catalog(self, json_dict, shell_version):
        pass

    def download(self, url, query):
        pass

    def install(self, file, path):
        pass

    def chek_installed(self, uuid):
        pass

    def remove(self, path):
        pass

    def activate(self, uuid):
        pass

    def deactivate(self, uuid):
        pass

class Catalog(object):
    def __init__(self, json_dict=None, indentation=2):
        self.catalog = json_dict or {}
        self.encoder = JSONEncoder(indent=indentation, separators=(',',':'))
        self.decoder = JSONDecoder()

    def __str__(self):
        return self.encoder.encode(self.catalog)

    def load(self, filename):
        """
        This method loads the catalog from file with the path <filename>
        """
        with open(filename, 'r') as f:
            self.catalog = self.decoder.decode(f.read())

    def save(self, filename):
        """
        This method saves the catalog to a file with the path <filename>
        """
        if not os.path.exists(filename):
            directory = os.path.dirname(filename)
            if not os.path.exists(directory):
                os.makedirs(directory)

        with open(filename, 'w') as f:
            f.write(str(self))

    def dump(self):
        """
        dums the catalog for debugging purpose
        """
        print self

    def update(self, url, query, item, timeout):
        """
        This method updates the catalog from the <url> with the <query>
        """
        try:
            response = urllib2.urlopen('{0}/{1}'.format(url, query), timeout=timeout)
        except urllib2.HTTPError, e:
            print 'The server couldn\'t fulfill the request.'
            print 'Error code: ', e.code
            sys.exit(1)
        except urllib2.URLError, e:
            print 'We failed to reach a server.'
            print 'Reason: ', e.reason
            sys.exit(1)

        info = response.read()
        raw_catalog = self.decoder.decode(info)

        # some sanity checks:
        if raw_catalog['numpages'] != 1:
            raise Exception("Can't download all extension!")
        else:
            print "downloaded {0} extensions".format(raw_catalog['total'])

        # writing some info values
        d = datetime.now()
        timestamp = {}
        timestamp['year'] = d.year
        timestamp['month'] = d.month
        timestamp['day'] = d.day
        timestamp['hour'] = d.hour
        timestamp['minute'] = d.minute
        timestamp['second'] = d.second
        self.catalog['timestamp'] = timestamp

        gem = {}
        gem['version'] = VERSION
        self.catalog['gnome-extension-manager'] = gem

        # add the extension with uuid
        extensions = {}
        for extension in raw_catalog[item]:
            extensions[extension['uuid']] = extension

        self.catalog['extensions'] = extensions

    def get_extension(self, shell_version, uuid):
        extensions = self.catalog['extensions']
        if uuid not in extensions:
            raise Exception("Can't find extension in catalog")
        e = Extension()
        return e.get_from_catalog(extensions[uuid], shell_version)

    def build_from_paths(self, *paths):
        dirs = []
        for path in paths:
            dirs += map(lambda x: "{0}/{1}".format(path,x), os.listdir(path))
        for directory in dirs:
            with open("{0}/metadata.json".format(directory), 'r') as f:
                print f.read()

def get_gnome_shell_version():
    """
    This function is to get the installed gnome-shell version
    """
    gnome_shell_version = re.sub(r'^\s*GNOME\s*Shell\s*((\d+\.)+\d+).*$', r'\1',
            subprocess.check_output(['gnome-shell', '--version'])
            )
    return gnome_shell_version.rstrip()

def gnome_versions_stack(version):
    """
    Helper method, which Returns a stack (list) of versions; with the most
    specific at top and the unspecific at bottom.

    So if you version is 3.15.1 the list is [ 3, 3.15, 3.15.1 ]
    """

    split_version = version.split('.')
    versions = []
    while split_version:
        versions.append('.'.join(split_version))
        del split_version[-1]

    versions.reverse()

    return versions

def find_in_catalog(catalog, extension, shell_version):
    """
    Find the Extension in the catalog and return some usefull information
    """
    if re.match(r'^\d+$', extension):
        ext_type = "pk"
        extension = int(extension)
    elif re.match(r'^.*@.*', extension):
        ext_type = "uuid"
    else:
        raise Exception("{0}is no valid Extension UUID nor a valid Package number!".format(extension))

    found = False
    for i in range(len(catalog)):
        if catalog[i][ext_type] == extension:
            found = True
            catalog_num = i
            break

    if not found:
        raise Exception("Can't find extension {0} in the catalog".format(extension))

    shell_versions_stack = gnome_versions_stack(shell_version)
    test_version = shell_versions_stack.pop()

    while test_version not in catalog[catalog_num]['shell_version_map']:
        if not shell_versions_stack:
            raise Exception("Can't find extension {0} for your version of GNOME Shell".format(extension))
        else:
            test_version = shell_versions_stack.pop()

    # TODO: This should be an object
    return {"install_pk" : catalog[catalog_num]["shell_version_map"][test_version]["pk"],
            "version": catalog[catalog_num]["shell_version_map"][test_version]["version"],
            "name": catalog[catalog_num]["name"],
            "creator": catalog[catalog_num]["creator"],
            "description": catalog[catalog_num]["description"],
            "uuid": catalog[catalog_num]["uuid"],
            }

def install_extension(url, install_dir, uuid, install_pk):
    """
    This function should install a single extension to the user directory
    """

    with tempfile.SpooledTemporaryFile() as f:
        print("download extension {0}".format(uuid))
        download_extension(
                "{0}/download-extension/{1}.shell-extension.zip?version_tag={2}".format(url, uuid, install_pk),
                f,
                report_hook=download_progress
                )
        print("install extension {0}".format(uuid))
        install_directory = os.path.join(install_dir, uuid)
        if not os.path.exists(install_directory):
            os.makedirs(install_directory)
        with zipfile.ZipFile(f, 'r') as z:
            z.extractall(install_directory)

def install_all_extensions(extensions, catalog_file, url, shell_version, install_dir):
    """
    This function get a list of extensions make some checks and then installs
    it in the correct version. The version which is installed is obtained
    from the catalog.
    """

    try:
        with open(catalog_file, 'r') as f:
            catalog = json.load(f)['extensions']
    except IOError:
        print("Can't find catalog file please run '{0} update' first".format(__file__))
        sys.exit(1)

    for extension in extensions:
        ext_info = find_in_catalog(catalog, extension, shell_version)
        install_extension(url, install_dir, ext_info["uuid"], ext_info["install_pk"])


def init_argparser():
    """
    This function does the whole parsing oft command line arguments
    """
    import argparse

    parser = argparse.ArgumentParser()

    parser.add_argument('-c', '--config',
            help='specify an alternative configuratin file. (default: {0})'.format(DEFAULT_CONFIG_FILE),
            default=DEFAULT_CONFIG_FILE,
            dest='config_file'
            )

    # Setup subcommands
    sub_commands = parser.add_subparsers(dest='command')

    # Adding all the subcommands
    install = sub_commands.add_parser('install',
            help='Download and install the extension'
            )
    remove = sub_commands.add_parser('remove',
            help='Deinstall an extension'
            )
    purge = sub_commands.add_parser('purge',
            help='Deinstall an extension and remove the configuration'
            )
    update = sub_commands.add_parser('update',
            help='Update the extensions catalog'
            )
    upgrade = sub_commands.add_parser('upgrade',
            help='Update the installed extensions'
            )
    activate = sub_commands.add_parser('activate',
            help='Activate an extensions'
            )
    deactivate = sub_commands.add_parser('deactivate',
            help='Deactivate an extensions'
            )

    install.add_argument('extensions', nargs='+')
    remove.add_argument('extensions', nargs='+')
    purge.add_argument('extensions', nargs='+')
    upgrade.add_argument('extensions', nargs='*')
    activate.add_argument('extensions', nargs='+')
    deactivate.add_argument('extensions', nargs='+')

    return parser

def init_confparser(config_file):
    """
    This parses the configuration file
    """
    import ConfigParser

    parser = ConfigParser.SafeConfigParser()

    parser.add_section('global')
    parser.set('global', 'timeout', str(DEFAULT_TIMEOUT))

    parser.add_section('Catalog')
    parser.set('Catalog', 'query', DEFAULT_QUERY)
    parser.set('Catalog', 'directory', os.path.join(DEFAULT_CACHE_DIR,
                'gnome-extension-manager',
                )
            )
    parser.set('Catalog', 'item', DEFAULT_ITEM)
    parser.set('Catalog', 'url', DEFAULT_BASE_URL)

    parser.add_section('Install')
    parser.set('Install', 'directory', DEFAULT_INSTALL_DIR)

    parser.read(config_file)

    return parser

if __name__ == '__main__':

    args, extra_args = init_argparser().parse_known_args()

    config = init_confparser(args.config_file)

    catalogfile = os.path.join(
            config.get('Catalog', 'directory'),
            'catalog.json',
            )
    catalog = Catalog()

    if args.command == 'update':
        catalog.update(
                url=config.get('Catalog', 'url'),
                query=config.get('Catalog', 'query'),
                item=config.get('Catalog', 'item'),
                timeout=float(config.get('global', 'timeout')),
                )
        catalog.save(filename=catalogfile)
    elif args.command == 'install':
        shell_version = get_gnome_shell_version()

        catalog.load(filename=catalogfile)
        #extensions_to_install = catalog.get_extension(shell_version, set(args.extensions))

        installed_extensions = Catalog()
        installed_extensions.build_from_paths(DEFAULT_GLOBAL_INSTALL_DIR, config.get('Install', 'directory'))
